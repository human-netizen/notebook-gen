\begin{Verbatim}[commandchars=\\\{\}]
/* * Description: Computes partial sums a[1] + a[2] + ... + a[pos], and updates single elements a[i],
 * taking the difference between the old and new value.
 * Time: Both operations are \PYGZdl{}O(\PYGZbs{}log N)\PYGZdl{}.
 * Status: Stress\PYGZhy{}tested
 * Note: 1\PYGZhy{}based indexing
 */
\PYGZsh{}pragma once

struct FT \PYGZob{}
    vector\PYGZlt{}ll\PYGZgt{} s;
    FT(int n) : s(n + 1) \PYGZob{}\PYGZcb{} // size + 1 for 1\PYGZhy{}based indexing
    
    void update(int pos, ll dif) \PYGZob{} // a[pos] += dif
        for (; pos \PYGZlt{} sz(s); pos += pos \PYGZam{} \PYGZhy{}pos) 
            s[pos] += dif;
    \PYGZcb{}
    
    ll query(int pos) \PYGZob{} // sum of values in [1, pos]
        ll res = 0;
        for (; pos \PYGZgt{} 0; pos \PYGZhy{}= pos \PYGZam{} \PYGZhy{}pos)
            res += s[pos];
        return res;
    \PYGZcb{}
    
    int lower\PYGZus{}bound(ll sum) \PYGZob{} // min pos st sum of [1, pos] \PYGZgt{}= sum
        // Returns n if no sum is \PYGZgt{}= sum, or 0 if empty sum is.
        if (sum \PYGZlt{}= 0) return 0;
        int pos = 0;
        for (int pw = 1 \PYGZlt{}\PYGZlt{} 25; pw; pw \PYGZgt{}\PYGZgt{}= 1) \PYGZob{}
            if (pos + pw \PYGZlt{} sz(s) \PYGZam{}\PYGZam{} s[pos + pw] \PYGZlt{} sum)
                pos += pw, sum \PYGZhy{}= s[pos];
        \PYGZcb{}
        return pos + 1;
    \PYGZcb{}
\PYGZcb{};
\end{Verbatim}
